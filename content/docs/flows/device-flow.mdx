---
title: Device Flow
description: The Device Authorization Flow (RFC 8628) enables authentication on devices with limited input capabilities.
---

The Device Authorization Flow (RFC 8628) enables authentication on devices with 
limited input capabilities, like smart TVs, CLI tools, or IoT devices.

## Overview

When a device can't easily handle browser redirects or has no keyboard, the Device 
Flow lets users authenticate by entering a short code on a separate device (like 
their phone or computer).

## How It Works

1. Device requests authorization from the provider
2. Provider returns a user code and verification URL
3. Device displays the code and URL to the user
4. User visits the URL on another device and enters the code
5. User authenticates and authorizes
6. Device polls the token endpoint until authorization completes
7. Provider returns access tokens to the device

<Callout type="info" title="Provider Support">
  Not all OAuth providers support Device Flow. GitHub, Google, and Microsoft are 
  common providers that do. Check your provider's documentation.
</Callout>

## Implementation

Here's a complete example using GitHub's Device Flow:

```rust title="device_flow.rs"
use authkestra_flow::DeviceFlow;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // GitHub's Device Authorization Flow endpoints
    let client_id = std::env::var("GITHUB_CLIENT_ID")
        .expect("GITHUB_CLIENT_ID must be set");
    let device_auth_url = "https://github.com/login/device/code";
    let token_url = "https://github.com/login/oauth/access_token";

    let flow = DeviceFlow::new(
        client_id,
        device_auth_url.to_string(),
        token_url.to_string(),
    );

    println!("Initiating device authorization flow...");

    // 1. Request device authorization
    let device_resp = flow
        .initiate_device_authorization(&["user", "repo"])
        .await?;

    // 2. Display the verification URL and code to the user
    println!("\n1. Open your browser and go to: {}", device_resp.verification_uri);
    println!("2. Enter the code: {}", device_resp.user_code);

    if let Some(complete_uri) = &device_resp.verification_uri_complete {
        println!("\nOR just open this URL directly: {}", complete_uri);
    }

    println!("\nWaiting for authorization...");

    // 3. Poll for the token (blocks until authorized or timeout)
    match flow.poll_for_token(&device_resp.device_code, device_resp.interval).await {
        Ok(token) => {
            println!("\nAuthorization successful!");
            println!("Access Token: {}", token.access_token);
            if let Some(scope) = token.scope {
                println!("Scopes: {}", scope);
            }
        }
        Err(e) => {
            eprintln!("\nAuthorization failed: {}", e);
        }
    }

    Ok(())
}
```

<Callout type="tip" title="Polling Interval">
  The `device_resp.interval` contains the minimum polling interval 
  (in seconds) specified by the provider. Polling more frequently may result in 
  rate limiting errors.
</Callout>

## Use Cases

Device Flow is ideal for:

- **CLI Applications:** Authenticate users in terminal-based tools
- **Smart TVs:** Login on devices with limited input
- **IoT Devices:** Secure authentication for connected devices
- **Gaming Consoles:** User authentication without a keyboard
- **Kiosk Mode:** Public terminals or shared devices

```rust
// Example: CLI tool authentication
fn main() {
    println!("Welcome to MyCLI!");
    println!("You need to authenticate to continue.\n");
    
    // Start device flow
    let token = authenticate_with_device_flow().await?;
    
    // Save token for future use
    save_token_to_config(&token)?;
    
    println!("Authenticated! You can now use the CLI.");
}
```
