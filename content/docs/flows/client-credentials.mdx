---
title: Client Credentials Flow
description: The Client Credentials flow is used for machine-to-machine (M2M) authentication.
---

The Client Credentials flow is used for machine-to-machine (M2M) authentication 
where no user interaction is required.

## Overview

Unlike user-facing OAuth flows, the Client Credentials grant authenticates the 
*application itself* rather than a user. The application presents its 
client ID and secret directly to the authorization server in exchange for an 
access token.

## When to Use

Use Client Credentials when:

- **Backend Services:** API-to-API communication between your services
- **Scheduled Jobs:** Cron jobs or background workers that need API access
- **Microservices:** Internal service authentication in a microservices architecture
- **CLI Tools:** Automated scripts that run without user intervention

<Callout type="warning" title="Not for User Authentication">
  Client Credentials should never be used to authenticate end users. Use the 
  Authorization Code flow or other user-facing flows instead.
</Callout>

## Implementation

```rust title="client_credentials.rs"
use authkestra_flow::ClientCredentialsFlow;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Get credentials from environment
    let client_id = std::env::var("CLIENT_ID")
        .expect("CLIENT_ID must be set");
    let client_secret = std::env::var("CLIENT_SECRET")
        .expect("CLIENT_SECRET must be set");
    let token_url = std::env::var("TOKEN_URL")
        .unwrap_or_else(|_| "https://example.com/oauth/token".to_string());

    println!("Starting Client Credentials Flow...");

    // Create the flow
    let flow = ClientCredentialsFlow::new(client_id, client_secret, token_url);

    // Request a token with optional scopes
    let scopes = ["read", "write"];
    
    match flow.get_token(Some(&scopes)).await {
        Ok(token) => {
            println!("Successfully obtained access token!");
            println!("Access Token: {}", token.access_token);
            
            if let Some(expires_in) = token.expires_in {
                println!("Expires in: {} seconds", expires_in);
            }
            if let Some(scope) = token.scope {
                println!("Scopes: {}", scope);
            }
        }
        Err(e) => {
            eprintln!("Failed to obtain access token: {}", e);
        }
    }

    Ok(())
}
```

Using the token in your API calls:

```rust
use reqwest::Client;

async fn call_protected_api(token: &str) -> Result<String, reqwest::Error> {
    let client = Client::new();
    
    let response = client
        .get("https://api.example.com/data")
        .bearer_auth(token)  // Add the access token
        .send()
        .await?
        .text()
        .await?;
    
    Ok(response)
}

// Usage
let token = flow.get_token(Some(&["read"])).await?;
let data = call_protected_api(&token.access_token).await?;
```

## Security Considerations

<Callout type="danger" title="Protect Your Secrets">
  - Never expose client secrets in client-side code or version control
  - Use environment variables or secure secret management
  - Rotate secrets regularly
  - Use the minimum required scopes
</Callout>

```rust
// Good: Load from environment
let secret = std::env::var("CLIENT_SECRET")?;

// Better: Use a secrets manager
let secret = secrets_manager.get_secret("oauth/client-secret").await?;

// Never: Hardcode secrets
let secret = "my-super-secret-key"; // DON'T DO THIS
```
