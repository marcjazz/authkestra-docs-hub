---
title: Axum Integration
description: Use authkestra-axum to integrate authentication into your Axum applications.
---

`authkestra-axum` provides a seamless integration for Axum applications, offering type-safe extractors, state management, and automatic route generation for OAuth providers.

## Introduction

The Axum adapter simplifies the process of adding authentication to your web services. By leveraging Axum's powerful extractor pattern and state management, Authkestra allows you to protect routes and manage user sessions with minimal configuration.

## State Management

Authkestra integrates with Axum's state system via `AuthkestraState`. This struct holds the configuration and provider registry required for authentication.

Depending on your application's needs, you can use `AuthkestraState` in two ways:

### Using AuthkestraState Directly

If your application does not require any additional custom state, you can use `AuthkestraState` directly as your application state:

```rust
use authkestra_axum::AuthkestraState;
use axum::Router;

// ... configure authkestra ...

let state = AuthkestraState { authkestra };

let app = Router::new()
    .merge(authkestra.axum_router())
    .with_state(state);
```

### Integration with Custom State

If your application already manages its own state, you should include `Authkestra` as a field within your custom state struct and implement the `FromRef` trait. This allows Authkestra's extractors (like `AuthSession`) to access the authentication configuration.

```rust
use authkestra_flow::Authkestra;
use axum::extract::FromRef;

#[derive(Clone)]
struct AppState {
    // Your other application state (e.g., database pool)
    pub db_pool: MyDbPool,
    /// Authkestra configuration
    pub auth_state: Authkestra,
}

// Implement FromRef to allow extractors to find AuthkestraState
impl FromRef<AppState> for Authkestra {
    fn from_ref(state: &AppState) -> Self {
        state.auth_state.clone()
    }
}
```

## Extractors

Authkestra provides several extractors to simplify authentication in your handlers.

### `AuthSession`

Used for session-based authentication.

```rust
use authkestra_axum::AuthSession;

async fn profile(AuthSession(session): AuthSession) -> String {
    format!("Welcome back, {}!", session.identity.username.unwrap_or_default())
}
```

### `AuthToken`

Used for JWT-based authentication.

```rust
use authkestra_axum::AuthToken;

async fn api_handler(AuthToken(claims): AuthToken) -> String {
    format!("Hello user with ID: {}", claims.sub)
}
```

### `Jwt<T>` (Offline Validation)

Used for validating tokens from external providers using JWKS.

```rust
use authkestra_axum::Jwt;
use serde::Deserialize;

#[derive(Deserialize)]
struct MyClaims {
    sub: String,
}

async fn external_api_handler(Jwt(claims): Jwt<MyClaims>) -> String {
    format!("Hello external user: {}", claims.sub)
}
```

## Multiple Providers

Authkestra makes it easy to support multiple authentication providers (e.g., GitHub, Google, Discord) within a single application using a flexible builder pattern.

### Using the Builder Pattern

You can configure multiple providers by chaining `.provider()` calls on the `Authkestra` builder. Each provider is typically wrapped in an `OAuth2Flow`.

```rust
use authkestra_axum::AuthkestraAxumExt;
use authkestra_flow::{Authkestra, OAuth2Flow};
use authkestra_providers_github::GithubProvider;

// ... other imports ...

let client_id = std::env::var("AUTHKESTRA_GITHUB_CLIENT_ID")?;
let client_secret = std::env::var("AUTHKESTRA_GITHUB_CLIENT_SECRET")?;
let redirect_uri = std::env::var("AUTHKESTRA_GITHUB_REDIRECT_URI")?;

let github = GithubProvider::new(client_id, client_secret, redirect_uri);

let authkestra = Authkestra::builder()
    .provider(OAuth2Flow::new(github))
    .session_store(my_session_store)
    .build();

let state = AppState {
    auth_state: AuthkestraState { authkestra },
};
```

## Router Integration

Instead of manually defining endpoints for every provider, you can use the `axum_router()` method to automatically register all necessary authentication routes.

### Merging the Router

The `axum_router()` method returns an Axum `Router` that you can merge into your main application. This automatically handles login redirection, callbacks, and logout for all configured providers.

```rust
use authkestra_axum::AuthkestraAxumExt;

let app = Router::new()
    .route("/", get(index))
    .route("/protected", get(protected))
    // Merge all Authkestra routes automatically
    .merge(authkestra.axum_router()) 
    .with_state(state);
```

By default, this registers:
- `GET /auth/:provider`: Initiates the login flow for a specific provider.
- `GET /auth/:provider/callback`: Handles the OAuth2 callback.
- `GET /auth/logout`: Clears the user session.

## SPA Example: JWT Authentication

In a Single Page Application (SPA), you typically want the backend to exchange the OAuth code for a JWT that the frontend can store and use for subsequent requests.

### SPA Flow and Redirect URI

For SPA use cases:
1. The `redirect_uri` in your OAuth provider configuration should point to a **frontend route** (e.g., `https://myapp.com/callback`).
2. Your frontend route should extract the `code` and `state` from the URL.
3. The frontend then performs a **POST** request to your backend's callback endpoint (e.g., `/api/auth/callback`) with these parameters.
4. The backend uses `handle_oauth_callback_jwt` to exchange the code for a JWT and returns it to the frontend.

## Conclusion

With Authkestra's Axum integration, you can move from a single-provider setup to a multi-provider system by simply adding more providers to the builder. The rest of your application remains clean and focused on your business logic.

For a complete working example featuring multiple providers and session management, see the [axum_oauth.rs](https://github.com/marcjazz/authkestra/blob/main/authkestra-examples/src/bin/axum_oauth.rs) file in the `authkestra-examples` directory on GitHub.
