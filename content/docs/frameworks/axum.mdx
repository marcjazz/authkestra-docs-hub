---
title: Axum Integration
description: Use authkestra-axum to integrate authentication into your Axum applications.
---

`authkestra-axum` provides a seamless integration for Axum applications, offering type-safe extractors, state management, and automatic route generation for OAuth providers.

## Introduction

The Axum adapter simplifies the process of adding authentication to your web services. By leveraging Axum's powerful extractor pattern and state management, Authkestra allows you to protect routes and manage user sessions with minimal configuration.

## State Management

Authkestra integrates with Axum's state system via `AuthkestraState`. This struct holds the configuration and provider registry needed for authentication.

### Implementing FromRef

For applications with custom state, you should include `AuthkestraState` in your state struct and implement the `FromRef` trait. This enables the use of Authkestra extractors like `AuthSession`.

```rust
use authkestra_axum::AuthkestraState;
use axum::extract::FromRef;

#[derive(Clone)]
struct AppState {
    // Your other application state
    auth_state: AuthkestraState,
}

impl FromRef<AppState> for AuthkestraState {
    fn from_ref(state: &AppState) -> Self {
        state.auth_state.clone()
    }
}
```

## Multiple Providers

Authkestra makes it easy to support multiple authentication providers (e.g., GitHub, Google, Discord) within a single application using a flexible builder pattern.

### Using the Builder Pattern

You can configure multiple providers by chaining `.provider()` calls on the `Authkestra` builder. Each provider is typically wrapped in an `OAuth2Flow`.

```rust
use authkestra_axum::Authkestra;
use authkestra_flow::OAuth2Flow;
use authkestra_providers_github::GithubProvider;
use authkestra_providers_google::GoogleProvider;

let github = GithubProvider::new(gh_id, gh_secret, gh_redirect);
let google = GoogleProvider::new(go_id, go_secret, go_redirect);

let authkestra = Authkestra::builder()
    .provider(OAuth2Flow::new(github))
    .provider(OAuth2Flow::new(google))
    .session_store(my_session_store)
    .build();

let state = AppState {
    auth_state: AuthkestraState { authkestra },
};
```

## Router Integration

Instead of manually defining endpoints for every provider, you can use the `axum_router()` method to automatically register all necessary authentication routes.

### Merging the Router

The `axum_router()` method returns an Axum `Router` that you can merge into your main application. This automatically handles login redirection, callbacks, and logout for all configured providers.

```rust
use authkestra_axum::AuthkestraAxumExt;

let app = Router::new()
    .route("/", get(index))
    .route("/protected", get(protected))
    // Merge all Authkestra routes automatically
    .merge(authkestra.axum_router()) 
    .with_state(state);
```

By default, this registers:
- `GET /auth/:provider`: Initiates the login flow for a specific provider.
- `GET /auth/:provider/callback`: Handles the OAuth2 callback.
- `GET /auth/logout`: Clears the user session.

## Conclusion

With Authkestra's Axum integration, you can move from a single-provider setup to a multi-provider system by simply adding more providers to the builder. The rest of your application remains clean and focused on your business logic.

For a complete working example featuring multiple providers and session management, see the [axum_oauth.rs](https://github.com/marcoruzzante/authkestra/blob/main/authkestra-examples/src/bin/axum_oauth.rs) file in the `authkestra-examples` directory on GitHub.
