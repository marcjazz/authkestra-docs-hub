---
title: Actix-web Integration
description: Use authkestra-actix to integrate authentication into your Actix-web applications.
---

`authkestra-actix` provides a seamless integration with [Actix Web](https://actix.rs/), offering type-safe extractors and helper functions to manage authentication flows with minimal boilerplate.

## Extractors

Authkestra provides two primary extractors to identify users in your request handlers:

### `AuthSession`
Used for **session-based authentication** (standard web apps). It attempts to find a session ID in the request cookies and retrieves the associated user identity from the session store.

```rust
use authkestra_actix::AuthSession;
use actix_web::{get, HttpResponse, Responder};

#[get("/profile")]
async fn profile(AuthSession(session): AuthSession) -> impl Responder {
    let identity = &session.identity;
    
    HttpResponse::Ok().json(serde_json::json!({
        "username": identity.username,
        "email": identity.email,
        "provider": identity.provider_id
    }))
}
```

### `AuthToken`
Used for **JWT-based authentication** (SPAs or Mobile apps). It validates a JWT provided in the `Authorization: Bearer <token>` header.

```rust
use authkestra_actix::AuthToken;

#[get("/api/protected")]
async fn protected_resource(AuthToken(claims): AuthToken) -> impl Responder {
    let identity = claims.identity.unwrap();
    HttpResponse::Ok().body(format!("Hello, {}!", identity.username.unwrap_or_default()))
}
```

## Route Registration

The `actix_scope()` helper method automatically registers the necessary OAuth routes (`/auth/{provider}/login` and `/auth/{provider}/callback`) for all providers configured in your `Authkestra` instance.

```rust
use authkestra_actix::AuthkestraActixExt;

App::new()
    .app_data(web::Data::new(authkestra.clone()))
    .service(authkestra.actix_scope()) // Registers /auth/... routes
```

---

## SPA Example: JWT Authentication

In a Single Page Application (SPA), you typically want the backend to exchange the OAuth code for a JWT that the frontend can store and use for subsequent requests.

### SPA Flow and Redirect URI

For SPA use cases:
1. The `redirect_uri` in your OAuth provider configuration should point to a **frontend route** (e.g., `https://myapp.com/callback`).
2. Your frontend route should extract the `code` and `state` from the URL.
3. The frontend then performs a **POST** request to your backend's callback endpoint (e.g., `/api/auth/callback`) with these parameters.
4. The backend uses `handle_oauth_callback_jwt_erased` to exchange the code for a JWT and returns it to the frontend.

### 1. Configure the Token Manager
To issue JWTs, you must provide a `TokenManager` to the `Authkestra` builder. This manager handles signing and verifying your application's tokens.

```rust
let token_manager = Arc::new(TokenManager::new(
    b"a-very-secret-key-that-is-at-least-32-bytes-long!!",
    None,
));

let authkestra = Authkestra::builder()
    .provider(OAuth2Flow::new(GithubProvider::new(client_id, client_secret, redirect_uri)))
    .token_manager(token_manager.clone())
    .build();
```

### 2. Handle the OAuth Callback
In SPA mode, your callback handler uses `handle_oauth_callback_jwt_erased`. Instead of setting a session cookie, this helper exchanges the OAuth code for an `AccessTokenResponse` containing your app's JWT.

```rust
use authkestra_actix::{handle_oauth_callback_jwt_erased, OAuthCallbackParams};

#[get("/api/callback")]
async fn callback_handler(
    data: web::Data<AppState>,
    params: web::Query<OAuthCallbackParams>,
    req: actix_web::HttpRequest,
) -> impl Responder {
    let flow = &data.authkestra.providers["github"];

    // ... other setup code ...

    handle_oauth_callback_jwt_erased(
        flow,
        &req,
        params.into_inner(),
        data.authkestra.token_manager.clone(),
        3600,
        &data.authkestra.session_config,
    )
    .await
    .map_err(actix_web::error::ErrorInternalServerError)
}
```

## Offline Validation

`authkestra-actix` provides a `Jwt<T>` extractor for offline token validation. This is useful for resource servers that need to validate tokens issued by external OIDC providers (like Google or Auth0) using their JWKS endpoint.

### Configuration

You need to register `Arc<JwksCache>` and `jsonwebtoken::Validation` in your `app_data`.

```rust
use authkestra_token::offline_validation::JwksCache;
use jsonwebtoken::{Algorithm, Validation};

// ... other setup code ...

let jwks_uri = "https://www.googleapis.com/oauth2/v3/certs".to_string();
let jwks_cache = Arc::new(JwksCache::new(jwks_uri, Duration::from_secs(3600)).await?);

let mut validation = Validation::new(Algorithm::RS256);
validation.set_issuer(&["https://accounts.google.com"]);

App::new()
    .app_data(web::Data::new(jwks_cache.clone()))
    .app_data(web::Data::new(validation.clone()))
```

### Usage

```rust
use authkestra_actix::Jwt;
use serde::Deserialize;

#[derive(Deserialize)]
struct MyClaims {
    sub: String,
}

#[get("/api/external")]
async fn external_api(Jwt(claims): Jwt<MyClaims>) -> impl Responder {
    HttpResponse::Ok().json(claims)
}
```

## Conclusion

By breaking down the authentication logic into extractors and specialized handlers, Authkestra allows you to support both traditional sessions and modern JWT-based flows with ease.

For a complete working implementation, including the frontend logic, check out the [actix_spa_jwt.rs](https://github.com/mscatena/authkestra/blob/main/authkestra-examples/src/bin/actix_spa_jwt.rs) example in our GitHub repository.
