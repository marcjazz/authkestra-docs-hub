---
title: Actix-web Integration
description: Use authkestra-actix to integrate authentication into your Actix-web applications.
---

Use `authkestra-actix` to integrate authentication into 
your Actix-web applications with type-safe extractors.

## Overview

The Actix adapter provides:

- `AuthSession` extractor for session-based auth
- `AuthToken` extractor for JWT-based auth
- Route helpers for automatic OAuth endpoint registration
- Session cookie management

## Setup

```toml title="Cargo.toml"
[dependencies]
authkestra = { version = "0.1.0", features = ["actix", "github", "session-sql"] }
actix-web = "4"
sqlx = { version = "0.7", features = ["runtime-tokio-rustls", "sqlite"] }
tokio = { version = "1", features = ["full"] }
dotenvy = "0.15"
```

## Extractors

`AuthSession` extracts the current user's session:

```rust
use authkestra_actix::AuthSession;
use actix_web::{get, HttpResponse, Responder};

#[get("/profile")]
async fn profile(session: AuthSession) -> impl Responder {
    let identity = &session.0.identity;
    
    HttpResponse::Ok().json(serde_json::json!({
        "username": identity.username,
        "email": identity.email,
        "provider": identity.provider_id
    }))
}

#[get("/dashboard")]
async fn dashboard(session: AuthSession) -> impl Responder {
    // If no valid session, AuthSession extraction fails with 401
    HttpResponse::Ok().body(format!(
        "Welcome to your dashboard, {}!",
        session.0.identity.username.as_deref().unwrap_or("User")
    ))
}
```

## Route Helpers

```rust
use authkestra_actix::AuthkestraActixExt;

App::new()
    .app_data(state.clone())
    .service(index)
    .service(protected)
    // This adds:
    // GET /auth/github - Initiates OAuth flow
    // GET /auth/github/callback - Handles OAuth callback
    .authkestra_routes(&authkestra)
```

## JWT Mode (SPA)

For single-page applications, use JWT tokens instead of session cookies:

```rust
use authkestra_actix::{AuthToken, handle_oauth_callback_jwt_erased};
use authkestra_token::TokenManager;

// Protected route using JWT
#[get("/api/user")]
async fn get_user(token: AuthToken) -> impl Responder {
    // Token is validated automatically
    HttpResponse::Ok().json(token.0.claims)
}

// Callback that returns JWT instead of setting cookie
#[get("/api/callback")]
async fn jwt_callback(
    query: web::Query<OAuthCallbackParams>,
    auth: web::Data<Authkestra>,
    token_manager: web::Data<TokenManager>,
) -> impl Responder {
    match handle_oauth_callback_jwt_erased(&auth, &token_manager, &query).await {
        Ok(jwt) => HttpResponse::Ok().json(serde_json::json!({
            "token": jwt,
            "type": "Bearer"
        })),
        Err(e) => HttpResponse::Unauthorized().body(e.to_string())
    }
}
```

<Callout type="info" title="SPA Flow">
  In SPA mode, the frontend receives the JWT and stores it (usually in localStorage). 
  It then includes the token in the `Authorization: Bearer` header 
  for API requests.
</Callout>

## Full Example

```rust title="actix_github.rs"
use actix_web::{get, web, App, HttpResponse, HttpServer, Responder};
use authkestra_actix::{AuthSession, AuthkestraActixExt};
use authkestra_core::{SessionConfig, SessionStore};
use authkestra_flow::{Authkestra, OAuth2Flow};
use authkestra_providers_github::GithubProvider;
use authkestra_session::SqlStore;
use sqlx::sqlite::SqlitePool;
use std::sync::Arc;

struct AppState {
    authkestra: Authkestra,
}

#[get("/")]
async fn index() -> impl Responder {
    HttpResponse::Ok().body(r#"
        <h1>Welcome!</h1>
        <a href="/auth/github">Login with GitHub</a>
    "#)
}

#[get("/protected")]
async fn protected(session: AuthSession) -> impl Responder {
    let name = session.0.identity.username.clone()
        .unwrap_or_else(|| "Unknown".to_string());

    HttpResponse::Ok().body(format!(
        "<h1>Hello, {}!</h1><p>You are authenticated via GitHub.</p>",
        name
    ))
}

#[actix_web::main]
async fn main() -> std::io::Result<()> {
    dotenvy::dotenv().ok();

    // Setup provider
    let provider = GithubProvider::new(
        std::env::var("GITHUB_CLIENT_ID").expect("GITHUB_CLIENT_ID required"),
        std::env::var("GITHUB_CLIENT_SECRET").expect("GITHUB_CLIENT_SECRET required"),
        "http://localhost:8080/auth/github/callback".to_string(),
    );

    // Setup session store
    let pool = SqlitePool::connect("sqlite::memory:").await.unwrap();
    sqlx::query("CREATE TABLE sessions (id TEXT PRIMARY KEY, data TEXT, expires_at INTEGER)")
        .execute(&pool).await.unwrap();
    let store = SqlStore::new(pool);

    // Build Authkestra
    let authkestra = Authkestra::builder()
        .provider(OAuth2Flow::new(provider))
        .session_store(store)
        .build();

    let state = web::Data::new(AppState { authkestra: authkestra.clone() });

    HttpServer::new(move || {
        App::new()
            .app_data(state.clone())
            .service(index)
            .service(protected)
            .authkestra_routes(&authkestra)  // Adds /auth/github and callback
    })
    .bind("127.0.0.1:8080")?
    .run()
    .await
}
```
