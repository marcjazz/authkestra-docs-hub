---
title: Actix-web Integration
description: Use authkestra-actix to integrate authentication into your Actix-web applications.
---

`authkestra-actix` provides a seamless integration with [Actix Web](https://actix.rs/), offering type-safe extractors and helper functions to manage authentication flows with minimal boilerplate.

## Extractors

Authkestra provides two primary extractors to identify users in your request handlers:

### `AuthSession`
Used for **session-based authentication** (standard web apps). It attempts to find a session ID in the request cookies and retrieves the associated user identity from the session store.

```rust
use authkestra_actix::AuthSession;
use actix_web::{get, HttpResponse, Responder};

#[get("/profile")]
async fn profile(session: AuthSession) -> impl Responder {
    let identity = &session.0.identity;
    
    HttpResponse::Ok().json(serde_json::json!({
        "username": identity.username,
        "email": identity.email,
        "provider": identity.provider_id
    }))
}
```

### `AuthToken`
Used for **JWT-based authentication** (SPAs or Mobile apps). It validates a JWT provided in the `Authorization: Bearer <token>` header.

```rust
use authkestra_actix::AuthToken;

#[get("/api/protected")]
async fn protected_resource(AuthToken(claims): AuthToken) -> impl Responder {
    let identity = claims.identity.unwrap();
    HttpResponse::Ok().body(format!("Hello, {}!", identity.username.unwrap_or_default()))
}
```

## Route Registration

The `actix_scope()` helper method automatically registers the necessary OAuth routes (`/auth/{provider}/login` and `/auth/{provider}/callback`) for all providers configured in your `Authkestra` instance.

```rust
use authkestra_actix::AuthkestraActixExt;

App::new()
    .app_data(web::Data::new(authkestra.clone()))
    .service(authkestra.actix_scope()) // Registers /auth/... routes
```

---

## SPA Example: JWT Authentication

In a Single Page Application (SPA), you typically want the backend to exchange the OAuth code for a JWT that the frontend can store and use for subsequent requests.

### 1. Configure the Token Manager
To issue JWTs, you must provide a `TokenManager` to the `Authkestra` builder. This manager handles signing and verifying your application's tokens.

```rust
let token_manager = Arc::new(TokenManager::new(
    b"a-very-secret-key-that-is-at-least-32-bytes-long!!",
    None,
));

let authkestra = Authkestra::builder()
    .provider(OAuth2Flow::new(GithubProvider::new(client_id, client_secret, redirect_uri)))
    .token_manager(token_manager.clone())
    .build();
```

### 2. Handle the OAuth Callback
In SPA mode, your callback handler uses `handle_oauth_callback_jwt_erased`. Instead of setting a session cookie, this helper exchanges the OAuth code for an `AccessTokenResponse` containing your app's JWT.

```rust
use authkestra_actix::{handle_oauth_callback_jwt_erased, OAuthCallbackParams};

#[get("/api/callback")]
async fn callback_handler(
    data: web::Data<AppState>,
    params: web::Query<OAuthCallbackParams>,
    req: actix_web::HttpRequest,
) -> impl Responder {
    let flow = &data.authkestra.providers["github"];

    let res = handle_oauth_callback_jwt_erased(
        flow,
        &req,
        params.into_inner(),
        data.authkestra.token_manager.clone(),
        3600, // Token expiration in seconds
        &data.authkestra.session_config,
    )
    .await;

    match res {
        Ok(token_resp) => token_resp, // Returns JSON with access_token
        Err(err) => HttpResponse::from_error(err),
    }
}
```

## Conclusion

By breaking down the authentication logic into extractors and specialized handlers, Authkestra allows you to support both traditional sessions and modern JWT-based flows with ease.

For a complete working implementation, including the frontend logic, check out the [actix_spa_jwt.rs](https://github.com/marcoruiz9/authkestra/blob/main/authkestra-examples/src/bin/actix_spa_jwt.rs) example in our GitHub repository.
